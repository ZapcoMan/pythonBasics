#!/usr/bin/env python3
"""
å·¥å…·æ¨¡å— - CVE-2025-55184 åˆ©ç”¨å·¥å…·çš„è¾…åŠ©å‡½æ•°
ä½œè€…: CyberTechAjju
"""

import json
import socket
import ssl
import validators
import dns.resolver
from urllib.parse import urlparse
from datetime import datetime
import os
import hashlib
from typing import Dict, List, Optional


class Utils:
    @staticmethod
    def validate_url(url: str) -> bool:
        """éªŒè¯URLæ ¼å¼"""
        return validators.url(url) is True
    
    @staticmethod
    def parse_target(target: str) -> Dict:
        """è§£æç›®æ ‡URLå¹¶æå–ç»„ä»¶"""
        if not target.startswith(('http://', 'https://')):
            target = 'http://' + target
        
        parsed = urlparse(target)
        
        return {
            'full_url': target,
            'scheme': parsed.scheme,
            'hostname': parsed.hostname,
            'port': parsed.port or (443 if parsed.scheme == 'https' else 80),
            'path': parsed.path or '/',
            'netloc': parsed.netloc
        }
    
    @staticmethod
    def resolve_dns(hostname: str) -> Optional[str]:
        """å°†ä¸»æœºåè§£æä¸ºIPåœ°å€"""
        try:
            answers = dns.resolver.resolve(hostname, 'A')
            return str(answers[0])
        except Exception as e:
            try:
                # å›é€€åˆ°socket
                return socket.gethostbyname(hostname)
            except:
                return None
    
    @staticmethod
    def check_ssl(hostname: str, port: int = 443) -> Dict:
        """æ£€æŸ¥SSL/TLSè¯ä¹¦"""
        try:
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    return {
                        'valid': True,
                        'issuer': dict(x[0] for x in cert['issuer']),
                        'subject': dict(x[0] for x in cert['subject']),
                        'version': cert['version'],
                        'not_after': cert['notAfter'],
                        'not_before': cert['notBefore']
                    }
        except Exception as e:
            return {
                'valid': False,
                'error': str(e)
            }
    
    @staticmethod
    def check_port_open(hostname: str, port: int, timeout: int = 3) -> bool:
        """æ£€æŸ¥ç«¯å£æ˜¯å¦å¼€æ”¾"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((hostname, port))
            sock.close()
            return result == 0
        except:
            return False
    
    @staticmethod
    def fingerprint_server(headers: Dict) -> Dict:
        """ä»å¤´éƒ¨ä¿¡æ¯æŒ‡çº¹è¯†åˆ«æœåŠ¡å™¨æŠ€æœ¯"""
        server_info = {
            'server': headers.get('Server', 'Unknown'),
            'powered_by': headers.get('X-Powered-By', 'Unknown'),
            'framework': 'Unknown',
            'waf': None
        }
        
        # æ£€æµ‹æ¡†æ¶
        header_str = str(headers).lower()
        
        if 'next' in header_str or '_next' in header_str:
            server_info['framework'] = 'Next.js'
        elif 'waku' in header_str:
            server_info['framework'] = 'Waku'
        elif 'remix' in header_str:
            server_info['framework'] = 'Remix'
        elif 'react' in header_str:
            server_info['framework'] = 'React'
        
        return server_info
    
    @staticmethod
    def load_config(config_path: str = 'config/config.json') -> Dict:
        """ä»JSONæ–‡ä»¶åŠ è½½é…ç½®"""
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
        except json.JSONDecodeError:
            return {}
    
    @staticmethod
    def load_payloads(payload_path: str = 'config/payloads.json') -> Dict:
        """ä»JSONæ–‡ä»¶åŠ è½½è½½è·"""
        try:
            with open(payload_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {'payloads': {}}
        except json.JSONDecodeError:
            return {'payloads': {}}
    
    @staticmethod
    def save_report(data: Dict, format: str = 'json', output_dir: str = './reports') -> str:
        """ä¿å­˜æŠ¥å‘Šåˆ°æ–‡ä»¶"""
        # åˆ›å»ºè¾“å‡ºç›®å½•
        os.makedirs(output_dir, exist_ok=True)
        
        # ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„æ–‡ä»¶å
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        target_hash = hashlib.md5(data.get('target', 'unknown').encode()).hexdigest()[:8]
        
        if format == 'json':
            filename = f"report_{target_hash}_{timestamp}.json"
            filepath = os.path.join(output_dir, filename)
            with open(filepath, 'w') as f:
                json.dump(data, f, indent=2)
        
        elif format == 'markdown':
            filename = f"report_{target_hash}_{timestamp}.md"
            filepath = os.path.join(output_dir, filename)
            md_content = Utils._generate_markdown_report(data)
            with open(filepath, 'w') as f:
                f.write(md_content)
        
        elif format == 'html':
            filename = f"report_{target_hash}_{timestamp}.html"
            filepath = os.path.join(output_dir, filename)
            html_content = Utils._generate_html_report(data)
            with open(filepath, 'w') as f:
                f.write(html_content)
        
        else:
            filename = f"report_{target_hash}_{timestamp}.txt"
            filepath = os.path.join(output_dir, filename)
            with open(filepath, 'w') as f:
                f.write(str(data))
        
        return filepath
    
    @staticmethod
    def _generate_markdown_report(data: Dict) -> str:
        """ç”Ÿæˆmarkdownæ ¼å¼çš„æŠ¥å‘Š"""
        md = f"""# CVE-2025-55184 æ¼æ´è¯„ä¼°æŠ¥å‘Š

**ç”Ÿæˆå·¥å…·:** CyberTechAjju å®‰å…¨å·¥å…·
**æ—¥æœŸ:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
**ç›®æ ‡:** {data.get('target', 'N/A')}

---

## æ‰§è¡Œæ‘˜è¦

**æ¼æ´çŠ¶æ€:** {"ğŸ”´ å­˜åœ¨æ¼æ´" if data.get('vulnerable') else "ğŸŸ¢ æ— æ¼æ´"}
**ç½®ä¿¡åº¦:** {data.get('confidence', 0)}%
**ä¸¥é‡æ€§:** {"é«˜" if data.get('vulnerable') else "N/A"}

## ç›®æ ‡ä¿¡æ¯

- **URL:** {data.get('target', 'N/A')}
- **æ¡†æ¶:** {data.get('framework', 'Unknown')}
- **æœåŠ¡å™¨:** {data.get('server', 'Unknown')}
- **IPåœ°å€:** {data.get('ip_address', 'Unknown')}

## æ¼æ´è¯¦æƒ…

**CVE-2025-55184** å½±å“Next.jsã€Wakuå’Œç±»ä¼¼æ¡†æ¶ä¸­çš„ReactæœåŠ¡å™¨ç»„ä»¶(RSC)å®ç°ã€‚è¯¥æ¼æ´å…è®¸æ”»å‡»è€…é€šè¿‡ç²¾å¿ƒæ„é€ çš„è½½è·è§¦å‘æ‹’ç»æœåŠ¡æ¡ä»¶ï¼Œè¿™äº›è½½è·ä¼šåœ¨RSCååºåˆ—åŒ–ä¸­å¯¼è‡´æ— é™é€’å½’ã€‚

### æ”»å‡»è¯¦æƒ…

- **ä½¿ç”¨è½½è·:** `{data.get('payload_used', 'N/A')}`
- **ç¼–ç æ–¹å¼:** {data.get('encoding', 'None')}
- **æˆåŠŸç‡:** {data.get('success_rate', 0)}%

### æµ‹è¯•ç»“æœ

{Utils._format_test_results(data.get('test_results', []))}

## WAFæ£€æµ‹

{Utils._format_waf_info(data.get('waf_info', {}))}

## å»ºè®®

{Utils._generate_recommendations(data)}

---

**æŠ¥å‘ŠID:** {hashlib.md5(str(data).encode()).hexdigest()}
**å·¥å…·ç‰ˆæœ¬:** 1.0.0
"""
        return md
    
    @staticmethod
    def _format_test_results(results: List) -> str:
        """æ ¼å¼åŒ–æµ‹è¯•ç»“æœä¸ºmarkdown"""
        if not results:
            return "æ— å¯ç”¨æµ‹è¯•ç»“æœã€‚"
        
        md = "| æµ‹è¯• | ç»“æœ | æ—¶é—´ |\n|------|--------|------|\n"
        for result in results:
            md += f"| {result.get('test', 'N/A')} | {result.get('result', 'N/A')} | {result.get('time', 'N/A')}s |\n"
        return md
    
    @staticmethod
    def _format_waf_info(waf_info: Dict) -> str:
        """æ ¼å¼åŒ–WAFä¿¡æ¯ä¸ºmarkdown"""
        if not waf_info.get('detected'):
            return "**çŠ¶æ€:** æœªæ£€æµ‹åˆ°WAF"
        
        return f"""**çŠ¶æ€:** æ£€æµ‹åˆ°WAF
**ç±»å‹:** {waf_info.get('type', 'Unknown')}
**ç½®ä¿¡åº¦:** {waf_info.get('confidence', 0)}%
**å°è¯•ç»•è¿‡:** {waf_info.get('bypass_attempted', 'No')}"""
    
    @staticmethod
    def _generate_recommendations(data: Dict) -> str:
        """ç”Ÿæˆä¿®å¤å»ºè®®"""
        if not data.get('vulnerable'):
            return "âœ… ç›®æ ‡ä¼¼ä¹å·²ä¿®è¡¥æˆ–æ— æ¼æ´ã€‚ç»§ç»­ç›‘æ§æ–°æ¼æ´ã€‚"
        
        return """### ç«‹å³è¡ŒåŠ¨

1. **æ›´æ–°ä¾èµ–**
   - æ›´æ–°Next.jsåˆ°14.1.1æˆ–æ›´é«˜ç‰ˆæœ¬
   - æ›´æ–°Reactåˆ°18.3.0æˆ–æ›´é«˜ç‰ˆæœ¬
   - æ›´æ–°@react-server-domåŒ…

2. **å®æ–½ç¼“è§£æªæ–½**
   - ä¸ºRSCè½½è·æ·»åŠ è¾“å…¥éªŒè¯
   - åœ¨RSCç«¯ç‚¹ä¸Šå®æ–½é€Ÿç‡é™åˆ¶
   - éƒ¨ç½²WAFè§„åˆ™ä»¥é˜»æ­¢æ¶æ„æ¨¡å¼

3. **ç›‘æ§å’Œæµ‹è¯•**
   - ç›‘æ§æœåŠ¡å™¨æ—¥å¿—ä¸­çš„åˆ©ç”¨å°è¯•
   - å®æ–½è‡ªåŠ¨åŒ–å›å½’æµ‹è¯•
   - ä¸ºå¼‚å¸¸CPU/å†…å­˜ä½¿ç”¨æƒ…å†µè®¾ç½®è­¦æŠ¥

### å‚è€ƒèµ„æ–™

- [CVE-2025-55184 è¯¦æƒ…](https://nvd.nist.gov/vuln/detail/CVE-2025-55184)
- [Next.js å®‰å…¨å…¬å‘Š](https://github.com/vercel/next.js/security/advisories)
"""
    
    @staticmethod
    def _generate_html_report(data: Dict) -> str:
        """ç”ŸæˆHTMLæ ¼å¼çš„æŠ¥å‘Š"""
        vulnerable = data.get('vulnerable', False)
        status_color = '#dc2626' if vulnerable else '#16a34a'
        status_text = 'å­˜åœ¨æ¼æ´' if vulnerable else 'æ— æ¼æ´'
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>CVE-2025-55184 æŠ¥å‘Š</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; background: #0f172a; color: #e2e8f0; }}
        .header {{ background: linear-gradient(135deg, #06b6d4, #8b5cf6); padding: 30px; border-radius: 10px; margin-bottom: 30px; }}
        .header h1 {{ margin: 0; color: white; }}
        .status {{ background: {status_color}; color: white; padding: 20px; border-radius: 8px; margin: 20px 0; }}
        .section {{ background: #1e293b; padding: 20px; margin: 20px 0; border-radius: 8px; border-left: 4px solid #06b6d4; }}
        .info-grid {{ display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }}
        .info-item {{ padding: 10px; background: #334155; border-radius: 4px; }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #475569; }}
        th {{ background: #334155; }}
        .footer {{ text-align: center; margin-top: 40px; color: #64748b; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ”’ CVE-2025-55184 å®‰å…¨è¯„ä¼°</h1>
        <p>ç”± CyberTechAjju å®‰å…¨å·¥å…·ç”Ÿæˆ</p>
        <p>{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
    </div>
    
    <div class="status">
        <h2>âš ï¸ çŠ¶æ€: {status_text}</h2>
        <p>ç½®ä¿¡åº¦: {data.get('confidence', 0)}%</p>
    </div>
    
    <div class="section">
        <h3>ğŸ“‹ ç›®æ ‡ä¿¡æ¯</h3>
        <div class="info-grid">
            <div class="info-item"><strong>URL:</strong> {data.get('target', 'N/A')}</div>
            <div class="info-item"><strong>æ¡†æ¶:</strong> {data.get('framework', 'Unknown')}</div>
            <div class="info-item"><strong>æœåŠ¡å™¨:</strong> {data.get('server', 'Unknown')}</div>
            <div class="info-item"><strong>IP:</strong> {data.get('ip_address', 'Unknown')}</div>
        </div>
    </div>
    
    <div class="section">
        <h3>ğŸ¯ æ”»å‡»è¯¦æƒ…</h3>
        <p><strong>è½½è·:</strong> <code>{data.get('payload_used', 'N/A')}</code></p>
        <p><strong>ç¼–ç :</strong> {data.get('encoding', 'None')}</p>
        <p><strong>æˆåŠŸç‡:</strong> {data.get('success_rate', 0)}%</p>
    </div>
    
    <div class="footer">
        <p>CyberTechAjju å®‰å…¨ç ”ç©¶å·¥å…· v1.0.0</p>
        <p>æŠ¥å‘ŠID: {hashlib.md5(str(data).encode()).hexdigest()}</p>
    </div>
</body>
</html>"""
        return html
    
    @staticmethod
    def format_timestamp() -> str:
        """è·å–æ ¼å¼åŒ–çš„æ—¶é—´æˆ³"""
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    @staticmethod
    def calculate_success_rate(successful: int, total: int) -> float:
        """è®¡ç®—æˆåŠŸç‡ç™¾åˆ†æ¯”"""
        if total == 0:
            return 0.0
        return (successful / total) * 100


if __name__ == "__main__":
    # æµ‹è¯•å·¥å…·
    utils = Utils()
    
    # æµ‹è¯•URLéªŒè¯
    print("æµ‹è¯•URLéªŒè¯:")
    print(utils.validate_url("https://example.com"))  # åº”ä¸ºTrue
    print(utils.validate_url("not-a-url"))  # åº”ä¸ºFalse
    
    # æµ‹è¯•URLè§£æ
    print("\næµ‹è¯•URLè§£æ:")
    parsed = utils.parse_target("https://example.com:3000/api/test")
    print(json.dumps(parsed, indent=2))